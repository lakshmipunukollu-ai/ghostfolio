(function() {
"use strict";
var __webpack_modules__ = ({
"./modules/logger/Logger.ts": (function (__unused_rspack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  Logger: function() { return WebpackLogger; }
});
/* import */ var _types__rspack_import_0 = __webpack_require__("./modules/types.ts");
function _instanceof(left, right) {
    if (right != null && typeof (typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }) !== "undefined" && right[(typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }).hasInstance]) {
        return !!right[(typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }).hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _class_call_check(instance, Constructor) {
    if (!_instanceof(instance, Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _iterable_to_array(iter) {
    if (typeof (typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }) !== "undefined" && iter[(typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }).iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _to_consumable_array(arr) {
    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}
/**
 * The following code is modified based on
 * https://github.com/webpack/webpack-dev-server
 *
 * MIT Licensed
 * Author Tobias Koppers @sokra
 * Copyright (c) JS Foundation and other contributors
 * https://github.com/webpack/webpack-dev-server/blob/main/LICENSE
 */ 
var LOG_SYMBOL = (typeof Symbol !== "undefined" ? Symbol : function (i) { return i; })('webpack logger raw log method');
var TIMERS_SYMBOL = (typeof Symbol !== "undefined" ? Symbol : function (i) { return i; })('webpack logger times');
var TIMERS_AGGREGATES_SYMBOL = (typeof Symbol !== "undefined" ? Symbol : function (i) { return i; })('webpack logger aggregated times');
var _LOG_SYMBOL = LOG_SYMBOL, _TIMERS_SYMBOL = TIMERS_SYMBOL, _TIMERS_AGGREGATES_SYMBOL = TIMERS_AGGREGATES_SYMBOL;
var WebpackLogger = /*#__PURE__*/ function() {
    "use strict";
    function WebpackLogger(log, getChildLogger) {
        _class_call_check(this, WebpackLogger);
        _define_property(this, _LOG_SYMBOL, void 0);
        _define_property(this, _TIMERS_SYMBOL, new Map());
        _define_property(this, _TIMERS_AGGREGATES_SYMBOL, new Map());
        // @ts-ignore
        _define_property(this, "getChildLogger", void 0);
        this[LOG_SYMBOL] = log;
        this.getChildLogger = getChildLogger;
    }
    _create_class(WebpackLogger, [
        {
            key: "error",
            value: function error() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                this[LOG_SYMBOL](_types__rspack_import_0.LogType.error, args);
            }
        },
        {
            key: "warn",
            value: function warn() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                this[LOG_SYMBOL](_types__rspack_import_0.LogType.warn, args);
            }
        },
        {
            key: "info",
            value: function info() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                this[LOG_SYMBOL](_types__rspack_import_0.LogType.info, args);
            }
        },
        {
            key: "log",
            value: function log() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                this[LOG_SYMBOL](_types__rspack_import_0.LogType.log, args);
            }
        },
        {
            key: "debug",
            value: function debug() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                this[LOG_SYMBOL](_types__rspack_import_0.LogType.debug, args);
            }
        },
        {
            key: "assert",
            value: function assert(assertion) {
                for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    args[_key - 1] = arguments[_key];
                }
                if (!assertion) {
                    this[LOG_SYMBOL](_types__rspack_import_0.LogType.error, args);
                }
            }
        },
        {
            key: "trace",
            value: function trace() {
                this[LOG_SYMBOL](_types__rspack_import_0.LogType.trace, [
                    'Trace'
                ]);
            }
        },
        {
            key: "clear",
            value: function clear() {
                this[LOG_SYMBOL](_types__rspack_import_0.LogType.clear);
            }
        },
        {
            key: "status",
            value: function status() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                this[LOG_SYMBOL](_types__rspack_import_0.LogType.status, args);
            }
        },
        {
            key: "group",
            value: function group() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                this[LOG_SYMBOL](_types__rspack_import_0.LogType.group, args);
            }
        },
        {
            key: "groupCollapsed",
            value: function groupCollapsed() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                this[LOG_SYMBOL](_types__rspack_import_0.LogType.groupCollapsed, args);
            }
        },
        {
            key: "groupEnd",
            value: function groupEnd() {
                this[LOG_SYMBOL](_types__rspack_import_0.LogType.groupEnd);
            }
        },
        {
            key: "profile",
            value: function profile(label) {
                this[LOG_SYMBOL](_types__rspack_import_0.LogType.profile, [
                    label
                ]);
            }
        },
        {
            key: "profileEnd",
            value: function profileEnd(label) {
                this[LOG_SYMBOL](_types__rspack_import_0.LogType.profileEnd, [
                    label
                ]);
            }
        },
        {
            key: "time",
            value: function time(label) {
                this[TIMERS_SYMBOL] = this[TIMERS_SYMBOL] || new Map();
                this[TIMERS_SYMBOL].set(label, process.hrtime());
            }
        },
        {
            key: "timeLog",
            value: function timeLog(label) {
                var prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);
                if (!prev) {
                    throw new Error("No such label '".concat(label, "' for WebpackLogger.timeLog()"));
                }
                var time = process.hrtime(prev);
                this[LOG_SYMBOL](_types__rspack_import_0.LogType.time, [
                    label
                ].concat(_to_consumable_array(time)));
            }
        },
        {
            key: "timeEnd",
            value: function timeEnd(label) {
                var prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);
                if (!prev) {
                    throw new Error("No such label '".concat(label, "' for WebpackLogger.timeEnd()"));
                }
                var time = process.hrtime(prev);
                /** @type {TimersMap} */ this[TIMERS_SYMBOL].delete(label);
                this[LOG_SYMBOL](_types__rspack_import_0.LogType.time, [
                    label
                ].concat(_to_consumable_array(time)));
            }
        },
        {
            key: "timeAggregate",
            value: function timeAggregate(label) {
                var prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);
                if (!prev) {
                    throw new Error("No such label '".concat(label, "' for WebpackLogger.timeAggregate()"));
                }
                var time = process.hrtime(prev);
                this[TIMERS_SYMBOL].delete(label);
                this[TIMERS_AGGREGATES_SYMBOL] = this[TIMERS_AGGREGATES_SYMBOL] || new Map();
                var current = this[TIMERS_AGGREGATES_SYMBOL].get(label);
                if (current !== undefined) {
                    if (time[1] + current[1] > 1e9) {
                        time[0] += current[0] + 1;
                        time[1] = time[1] - 1e9 + current[1];
                    } else {
                        time[0] += current[0];
                        time[1] += current[1];
                    }
                }
                this[TIMERS_AGGREGATES_SYMBOL].set(label, time);
            }
        },
        {
            key: "timeAggregateEnd",
            value: function timeAggregateEnd(label) {
                if (this[TIMERS_AGGREGATES_SYMBOL] === undefined) return;
                var time = this[TIMERS_AGGREGATES_SYMBOL].get(label);
                if (time === undefined) return;
                this[TIMERS_AGGREGATES_SYMBOL].delete(label);
                this[LOG_SYMBOL](_types__rspack_import_0.LogType.time, [
                    label
                ].concat(_to_consumable_array(time)));
            }
        }
    ]);
    return WebpackLogger;
}();



}),
"./modules/logger/createConsoleLogger.ts": (function (__unused_rspack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  "default": function() { return /* export default binding */ __rspack_default_export; }
});
/* import */ var _types__rspack_import_0 = __webpack_require__("./modules/types.ts");
function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes(arr) {
    if (Array.isArray(arr)) return arr;
}
function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _iterable_to_array(iter) {
    if (typeof (typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }) !== "undefined" && iter[(typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }).iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _iterable_to_array_limit(arr, i) {
    var _i = arr == null ? null : typeof (typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }) !== "undefined" && arr[(typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }).iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array(arr, i) {
    return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _to_consumable_array(arr) {
    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _type_of(obj) {
    "@swc/helpers - typeof";
    return obj && typeof (typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }) !== "undefined" && obj.constructor === (typeof Symbol !== "undefined" ? Symbol : function (i) { return i; }) ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}
/**
 * The following code is modified based on
 * https://github.com/webpack/webpack-dev-server
 *
 * MIT Licensed
 * Author Tobias Koppers @sokra
 * Copyright (c) JS Foundation and other contributors
 * https://github.com/webpack/webpack-dev-server/blob/main/LICENSE
 */ 
var filterToFunction = function filterToFunction(item) {
    if (typeof item === 'string') {
        var regExp = new RegExp("[\\\\/]".concat(item.replace(/[-[\]{}()*+?.\\^$|]/g, '\\$&'), "([\\\\/]|$|!|\\?)"));
        return function(ident) {
            return regExp.test(ident);
        };
    }
    if (item && (typeof item === "undefined" ? "undefined" : _type_of(item)) === 'object' && typeof item.test === 'function') {
        return function(ident) {
            return item.test(ident);
        };
    }
    if (typeof item === 'function') {
        return item;
    }
    if (typeof item === 'boolean') {
        return function() {
            return item;
        };
    }
};
var LogLevel = {
    none: 6,
    false: 6,
    error: 5,
    warn: 4,
    info: 3,
    log: 2,
    true: 2,
    verbose: 1
};
/* export default */ function __rspack_default_export(param) {
    var _param_level = param.level, level = _param_level === void 0 ? 'info' : _param_level, _param_debug = param.debug, debug = _param_debug === void 0 ? false : _param_debug, console = param.console;
    var debugFilters = typeof debug === 'boolean' ? [
        function() {
            return debug;
        }
    ] : _to_consumable_array(Array.isArray(debug) ? debug : [
        debug
    ]).map(filterToFunction);
    var loglevel = LogLevel["".concat(level)] || 0;
    var logger = function logger(name, type, args) {
        var labeledArgs = function labeledArgs() {
            if (Array.isArray(args)) {
                if (args.length > 0 && typeof args[0] === 'string') {
                    return [
                        "[".concat(name, "] ").concat(args[0])
                    ].concat(_to_consumable_array(args.slice(1)));
                }
                return [
                    "[".concat(name, "]")
                ].concat(_to_consumable_array(args));
            }
            return [];
        };
        var debug = debugFilters.some(function(f) {
            return f(name);
        });
        switch(type){
            case _types__rspack_import_0.LogType.debug:
                if (!debug) return;
                if (typeof console.debug === 'function') {
                    var _console;
                    (_console = console).debug.apply(_console, _to_consumable_array(labeledArgs()));
                } else {
                    var _console1;
                    (_console1 = console).log.apply(_console1, _to_consumable_array(labeledArgs()));
                }
                break;
            case _types__rspack_import_0.LogType.log:
                var _console2;
                if (!debug && loglevel > LogLevel.log) return;
                (_console2 = console).log.apply(_console2, _to_consumable_array(labeledArgs()));
                break;
            case _types__rspack_import_0.LogType.info:
                var _console3;
                if (!debug && loglevel > LogLevel.info) return;
                (_console3 = console).info.apply(_console3, _to_consumable_array(labeledArgs()));
                break;
            case _types__rspack_import_0.LogType.warn:
                var _console4;
                if (!debug && loglevel > LogLevel.warn) return;
                (_console4 = console).warn.apply(_console4, _to_consumable_array(labeledArgs()));
                break;
            case _types__rspack_import_0.LogType.error:
                var _console5;
                if (!debug && loglevel > LogLevel.error) return;
                (_console5 = console).error.apply(_console5, _to_consumable_array(labeledArgs()));
                break;
            case _types__rspack_import_0.LogType.trace:
                if (!debug) return;
                console.trace();
                break;
            case _types__rspack_import_0.LogType.groupCollapsed:
                if (!debug && loglevel > LogLevel.log) return;
                if (!debug && loglevel > LogLevel.verbose) {
                    if (typeof console.groupCollapsed === 'function') {
                        var _console6;
                        (_console6 = console).groupCollapsed.apply(_console6, _to_consumable_array(labeledArgs()));
                    } else {
                        var _console7;
                        (_console7 = console).log.apply(_console7, _to_consumable_array(labeledArgs()));
                    }
                    break;
                }
            // falls through
            case _types__rspack_import_0.LogType.group:
                if (!debug && loglevel > LogLevel.log) return;
                if (typeof console.group === 'function') {
                    var _console8;
                    (_console8 = console).group.apply(_console8, _to_consumable_array(labeledArgs()));
                } else {
                    var _console9;
                    (_console9 = console).log.apply(_console9, _to_consumable_array(labeledArgs()));
                }
                break;
            case _types__rspack_import_0.LogType.groupEnd:
                if (!debug && loglevel > LogLevel.log) return;
                if (typeof console.groupEnd === 'function') {
                    console.groupEnd();
                }
                break;
            case _types__rspack_import_0.LogType.time:
                {
                    if (!debug && loglevel > LogLevel.log) return;
                    var _args = _sliced_to_array(args, 3), label = _args[0], start = _args[1], end = _args[2];
                    var ms = start * 1000 + end / 1000000;
                    var msg = "[".concat(name, "] ").concat(label, ": ").concat(ms, " ms");
                    if (typeof console.logTime === 'function') {
                        console.logTime(msg);
                    } else {
                        console.log(msg);
                    }
                    break;
                }
            case _types__rspack_import_0.LogType.profile:
                if (typeof console.profile === 'function') {
                    var _console10;
                    (_console10 = console).profile.apply(_console10, _to_consumable_array(labeledArgs()));
                }
                break;
            case _types__rspack_import_0.LogType.profileEnd:
                if (typeof console.profileEnd === 'function') {
                    var _console11;
                    (_console11 = console).profileEnd.apply(_console11, _to_consumable_array(labeledArgs()));
                }
                break;
            case _types__rspack_import_0.LogType.clear:
                if (!debug && loglevel > LogLevel.log) return;
                if (typeof console.clear === 'function') {
                    console.clear();
                }
                break;
            case _types__rspack_import_0.LogType.status:
                if (!debug && loglevel > LogLevel.info) return;
                if (typeof console.status === 'function') {
                    if (!args || args.length === 0) {
                        console.status();
                    } else {
                        var _console12;
                        (_console12 = console).status.apply(_console12, _to_consumable_array(labeledArgs()));
                    }
                } else if (args && args.length !== 0) {
                    var _console13;
                    (_console13 = console).info.apply(_console13, _to_consumable_array(labeledArgs()));
                }
                break;
            default:
                throw new Error("Unexpected LogType ".concat(type));
        }
    };
    return logger;
}


}),
"./modules/logger/runtime.ts": (function (__unused_rspack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  configureDefaultLogger: function() { return configureDefaultLogger; },
  getLogger: function() { return getLogger; },
  hooks: function() { return hooks; }
});
/* import */ var _tapable__rspack_import_0 = __webpack_require__("./modules/logger/tapable.ts");
/* import */ var _Logger__rspack_import_1 = __webpack_require__("./modules/logger/Logger.ts");
/* import */ var _createConsoleLogger__rspack_import_2 = __webpack_require__("./modules/logger/createConsoleLogger.ts");
/**
 * The following code is modified based on
 * https://github.com/webpack/webpack-dev-server
 *
 * MIT Licensed
 * Author Tobias Koppers @sokra
 * Copyright (c) JS Foundation and other contributors
 * https://github.com/webpack/webpack-dev-server/blob/main/LICENSE
 */ 


var currentDefaultLoggerOptions = {
    level: 'info',
    debug: false,
    console: console
};
var currentDefaultLogger = (0,_createConsoleLogger__rspack_import_2["default"])(currentDefaultLoggerOptions);
var configureDefaultLogger = function configureDefaultLogger(options) {
    Object.assign(currentDefaultLoggerOptions, options);
    currentDefaultLogger = (0,_createConsoleLogger__rspack_import_2["default"])(currentDefaultLoggerOptions);
};
var getLogger = function getLogger1(name) {
    return new _Logger__rspack_import_1.Logger(function(type, args) {
        if (hooks.log.call(name, type, args) === undefined) {
            currentDefaultLogger(name, type, args);
        }
    }, function(childName) {
        return getLogger("".concat(name, "/").concat(childName));
    });
};
var hooks = {
    // @ts-ignore
    log: new _tapable__rspack_import_0.SyncBailHook([
        'origin',
        'type',
        'args'
    ])
};

/* export default */ __webpack_exports__["default"] = ({
    getLogger: getLogger,
    configureDefaultLogger: configureDefaultLogger,
    hooks: hooks
});


}),
"./modules/logger/tapable.ts": (function (__unused_rspack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  SyncBailHook: function() { return SyncBailHook; }
});
/**
 * The following code is modified based on
 * https://github.com/webpack/webpack-dev-server
 *
 * MIT Licensed
 * Author Tobias Koppers @sokra
 * Copyright (c) JS Foundation and other contributors
 * https://github.com/webpack/webpack-dev-server/blob/main/LICENSE
 */ function SyncBailHook() {
    return {
        call: function call() {}
    };
}
/**
 * Client stub for tapable SyncBailHook
 */ 


}),
"./modules/types.ts": (function (__unused_rspack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  LogType: function() { return LogType; }
});
var LogType = Object.freeze({
    error: 'error',
    warn: 'warn',
    info: 'info',
    log: 'log',
    debug: 'debug',
    trace: 'trace',
    group: 'group',
    groupCollapsed: 'groupCollapsed',
    groupEnd: 'groupEnd',
    profile: 'profile',
    profileEnd: 'profileEnd',
    time: 'time',
    clear: 'clear',
    status: 'status'
});


}),

});
// The module cache
var __webpack_module_cache__ = {};

// The require function
function __webpack_require__(moduleId) {

// Check if module is in cache
var cachedModule = __webpack_module_cache__[moduleId];
if (cachedModule !== undefined) {
return cachedModule.exports;
}
// Create a new module (and put it into the cache)
var module = (__webpack_module_cache__[moduleId] = {
exports: {}
});
// Execute the module function
__webpack_modules__[moduleId](module, module.exports, __webpack_require__);

// Return the exports of the module
return module.exports;

}

// webpack/runtime/define_property_getters
!function() {
__webpack_require__.d = function(exports, definition) {
	for(var key in definition) {
        if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
            Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
        }
    }
};
}();
// webpack/runtime/has_own_property
!function() {
__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
}();
// webpack/runtime/make_namespace_object
!function() {
// define __esModule on exports
__webpack_require__.r = function(exports) {
	if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
		Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
	}
	Object.defineProperty(exports, '__esModule', { value: true });
};
}();
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
!function() {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  "default": function() { return /* reexport safe */ _runtime__rspack_import_0["default"]; }
});
/* import */ var _runtime__rspack_import_0 = __webpack_require__("./modules/logger/runtime.ts");
/**
 * The following code is modified based on
 * https://github.com/webpack/webpack-dev-server
 *
 * MIT Licensed
 * Author Tobias Koppers @sokra
 * Copyright (c) JS Foundation and other contributors
 * https://github.com/webpack/webpack-dev-server/blob/main/LICENSE
 */ 

}();
var __rspack_exports_target = exports;
for(var __rspack_i in __webpack_exports__) __rspack_exports_target[__rspack_i] = __webpack_exports__[__rspack_i];
if(__webpack_exports__.__esModule) Object.defineProperty(__rspack_exports_target, '__esModule', { value: true });
})()
;