"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = updateSelectorPlaygroundApi;
const devkit_1 = require("@nx/devkit");
const ensure_typescript_1 = require("@nx/js/src/utils/typescript/ensure-typescript");
const tsquery_1 = require("@phenomnomnominal/tsquery");
const migrations_1 = require("../../utils/migrations");
let printer;
let ts;
async function updateSelectorPlaygroundApi(tree) {
    for await (const { projectConfig } of (0, migrations_1.cypressProjectConfigs)(tree)) {
        (0, devkit_1.visitNotIgnoredFiles)(tree, projectConfig.root, (filePath) => {
            if (!isJsTsFile(filePath) || !tree.exists(filePath)) {
                return;
            }
            const originalContent = tree.read(filePath, 'utf-8');
            const updatedContent = migrateSelectorPlaygroundApi(originalContent);
            if (updatedContent !== originalContent) {
                tree.write(filePath, updatedContent);
            }
        });
    }
    await (0, devkit_1.formatFiles)(tree);
}
function migrateSelectorPlaygroundApi(fileContent) {
    let updated = fileContent;
    if (updated.includes('Cypress.SelectorPlayground')) {
        updated = updated.replace(/Cypress\.SelectorPlayground/g, 'Cypress.ElementSelector');
    }
    if (!updated.includes('Cypress.ElementSelector') &&
        !updated.includes('Cypress.SelectorPlayground')) {
        return updated;
    }
    ts ??= (0, ensure_typescript_1.ensureTypescript)();
    printer ??= ts.createPrinter();
    const sourceFile = (0, tsquery_1.ast)(updated);
    let hasChanges = false;
    const result = (0, tsquery_1.replace)(updated, 'CallExpression:has(Identifier[name="defaults"])', (node) => {
        if (!ts.isPropertyAccessExpression(node.expression)) {
            return node.getText();
        }
        if (node.expression.name.getText() !== 'defaults') {
            return node.getText();
        }
        const selectorExpr = node.expression.expression;
        if (!ts.isPropertyAccessExpression(selectorExpr)) {
            return node.getText();
        }
        if (!ts.isIdentifier(selectorExpr.expression)) {
            return node.getText();
        }
        if (selectorExpr.expression.text !== 'Cypress') {
            return node.getText();
        }
        const selectorName = selectorExpr.name.getText();
        if (selectorName !== 'ElementSelector' &&
            selectorName !== 'SelectorPlayground') {
            return node.getText();
        }
        if (!node.arguments.length) {
            return node.getText();
        }
        const [firstArg, ...restArgs] = node.arguments;
        if (!ts.isObjectLiteralExpression(firstArg)) {
            return node.getText();
        }
        const filteredProperties = firstArg.properties.filter((prop) => {
            if (ts.isPropertyAssignment(prop) ||
                ts.isShorthandPropertyAssignment(prop) ||
                ts.isMethodDeclaration(prop) ||
                ts.isGetAccessorDeclaration(prop) ||
                ts.isSetAccessorDeclaration(prop)) {
                return !isOnElementProperty(prop.name);
            }
            return true;
        });
        if (filteredProperties.length === firstArg.properties.length) {
            return node.getText();
        }
        hasChanges = true;
        const updatedObjectLiteral = ts.factory.updateObjectLiteralExpression(firstArg, filteredProperties);
        const updatedCall = ts.factory.updateCallExpression(node, node.expression, node.typeArguments, [updatedObjectLiteral, ...restArgs]);
        return printer.printNode(ts.EmitHint.Unspecified, updatedCall, sourceFile);
    });
    return hasChanges ? result : updated;
}
function isOnElementProperty(name) {
    ts ??= (0, ensure_typescript_1.ensureTypescript)();
    if (ts.isIdentifier(name)) {
        return name.text === 'onElement';
    }
    if (ts.isStringLiteralLike(name)) {
        return name.text === 'onElement';
    }
    return false;
}
function isJsTsFile(filePath) {
    return /\.[cm]?[jt]sx?$/.test(filePath);
}
