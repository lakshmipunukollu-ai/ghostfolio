"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = renameCyExecCodeProperty;
const devkit_1 = require("@nx/devkit");
const ensure_typescript_1 = require("@nx/js/src/utils/typescript/ensure-typescript");
const tsquery_1 = require("@phenomnomnominal/tsquery");
const migrations_1 = require("../../utils/migrations");
let ts;
async function renameCyExecCodeProperty(tree) {
    for await (const { projectConfig } of (0, migrations_1.cypressProjectConfigs)(tree)) {
        (0, devkit_1.visitNotIgnoredFiles)(tree, projectConfig.root, (filePath) => {
            if (!isJsTsFile(filePath) || !tree.exists(filePath)) {
                return;
            }
            const originalContent = tree.read(filePath, 'utf-8');
            const updatedContent = updateCyExecItsCalls(originalContent);
            if (updatedContent !== originalContent) {
                tree.write(filePath, updatedContent);
            }
        });
    }
    await (0, devkit_1.formatFiles)(tree);
}
function updateCyExecItsCalls(fileContent) {
    // quick check to avoid parsing the file if it doesn't contain the string
    if (!fileContent.includes("its('code')") &&
        !fileContent.includes('its("code")') &&
        !fileContent.includes('its(`code`)')) {
        return fileContent;
    }
    ts ??= (0, ensure_typescript_1.ensureTypescript)();
    const sourceFile = (0, tsquery_1.ast)(fileContent);
    const updates = [];
    const callExpressions = (0, tsquery_1.query)(sourceFile, 'CallExpression:has(PropertyAccessExpression > Identifier[name="its"])');
    for (const callExpression of callExpressions) {
        if (!shouldUpdateCallExpression(callExpression)) {
            continue;
        }
        const firstArg = callExpression.arguments[0];
        const literalText = firstArg.getText(sourceFile);
        const quote = literalText[0];
        const replacementText = `${quote}exitCode${quote}`;
        updates.push({
            start: firstArg.getStart(sourceFile),
            end: firstArg.getEnd(),
            text: replacementText,
        });
    }
    if (!updates.length) {
        return fileContent;
    }
    let updatedContent = fileContent;
    for (const update of updates.sort((a, b) => b.start - a.start)) {
        updatedContent =
            updatedContent.slice(0, update.start) +
                update.text +
                updatedContent.slice(update.end);
    }
    return updatedContent;
}
function shouldUpdateCallExpression(node) {
    if (!node.arguments.length) {
        return false;
    }
    ts ??= (0, ensure_typescript_1.ensureTypescript)();
    const firstArg = node.arguments[0];
    if (!(ts.isStringLiteral(firstArg) ||
        ts.isNoSubstitutionTemplateLiteral(firstArg)) ||
        firstArg.text !== 'code') {
        return false;
    }
    if (!ts.isPropertyAccessExpression(node.expression)) {
        return false;
    }
    if (node.expression.name.getText() !== 'its') {
        return false;
    }
    return isDerivedFromCyExec(node.expression.expression);
}
function isDerivedFromCyExec(expression) {
    ts ??= (0, ensure_typescript_1.ensureTypescript)();
    if (ts.isCallExpression(expression)) {
        return isDerivedFromCyExec(expression.expression);
    }
    if (ts.isPropertyAccessExpression(expression)) {
        if (expression.name.getText() === 'exec' &&
            ts.isIdentifier(expression.expression) &&
            expression.expression.text === 'cy') {
            return true;
        }
        return isDerivedFromCyExec(expression.expression);
    }
    return false;
}
function isJsTsFile(filePath) {
    return /\.[cm]?[jt]sx?$/.test(filePath);
}
