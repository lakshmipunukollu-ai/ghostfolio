"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateTsconfigFiles = updateTsconfigFiles;
const devkit_1 = require("@nx/devkit");
const js_1 = require("@nx/js");
const configuration_1 = require("@nx/js/src/utils/typescript/configuration");
const semver_1 = require("semver");
const tsconfig_utils_1 = require("../../utils/tsconfig-utils");
const update_app_editor_tsconfig_excluded_files_1 = require("../../utils/update-app-editor-tsconfig-excluded-files");
const version_utils_1 = require("../../utils/version-utils");
const enable_strict_type_checking_1 = require("./enable-strict-type-checking");
function updateTsconfigFiles(tree, options) {
    (0, enable_strict_type_checking_1.enableStrictTypeChecking)(tree, options);
    updateEditorTsConfig(tree, options);
    const compilerOptions = {
        skipLibCheck: true,
        experimentalDecorators: true,
        importHelpers: true,
        isolatedModules: true,
        target: 'es2022',
        moduleResolution: 'bundler',
    };
    const rootTsConfigPath = (0, js_1.getRootTsConfigFileName)(tree);
    const { major: angularMajorVersion, version: angularVersion } = (0, version_utils_1.getInstalledAngularVersionInfo)(tree);
    if ((0, semver_1.gte)(angularVersion, '19.1.0')) {
        // Angular started warning about emitDecoratorMetadata and isolatedModules
        // in v19.1.0. If enabled in the root tsconfig, we need to disable it.
        if ((0, tsconfig_utils_1.getDefinedCompilerOption)(tree, rootTsConfigPath, 'emitDecoratorMetadata') === true) {
            compilerOptions.emitDecoratorMetadata = false;
        }
    }
    if (angularMajorVersion >= 21) {
        compilerOptions.moduleResolution = 'bundler';
    }
    if (angularMajorVersion >= 20) {
        compilerOptions.module = 'preserve';
    }
    else {
        compilerOptions.module = 'es2022';
        if (options.bundler === 'esbuild') {
            compilerOptions.esModuleInterop = true;
        }
    }
    const tsconfigPath = (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'tsconfig.json');
    (0, devkit_1.updateJson)(tree, tsconfigPath, (json) => {
        json.compilerOptions = {
            ...json.compilerOptions,
            ...compilerOptions,
        };
        json.compilerOptions = (0, configuration_1.getNeededCompilerOptionOverrides)(tree, json.compilerOptions, rootTsConfigPath);
        return json;
    });
    if (options.unitTestRunner === 'jest') {
        const tsconfigSpecPath = (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'tsconfig.spec.json');
        (0, devkit_1.updateJson)(tree, tsconfigSpecPath, (json) => {
            json.compilerOptions = {
                ...json.compilerOptions,
                module: 'commonjs',
                moduleResolution: 'node10',
            };
            json.compilerOptions = (0, configuration_1.getNeededCompilerOptionOverrides)(tree, json.compilerOptions, tsconfigPath);
            return json;
        });
    }
}
function updateEditorTsConfig(tree, options) {
    const tsconfigEditorPath = (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'tsconfig.editor.json');
    if (!tree.exists(tsconfigEditorPath)) {
        return;
    }
    const appTsConfig = (0, devkit_1.readJson)(tree, (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'tsconfig.app.json'));
    const types = appTsConfig?.compilerOptions?.types ?? [];
    if (types?.length) {
        (0, devkit_1.updateJson)(tree, (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'tsconfig.editor.json'), (json) => {
            json.compilerOptions ??= {};
            json.compilerOptions.types = Array.from(new Set(types));
            return json;
        });
    }
    const project = (0, devkit_1.readProjectConfiguration)(tree, options.name);
    (0, update_app_editor_tsconfig_excluded_files_1.updateAppEditorTsConfigExcludedFiles)(tree, project);
}
